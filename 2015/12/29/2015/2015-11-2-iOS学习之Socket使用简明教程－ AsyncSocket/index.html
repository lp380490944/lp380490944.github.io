<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS学习之Socket使用简明教程－ AsyncSocket | 钟灵毓秀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS学习之Socket使用简明教程－ AsyncSocket">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS学习之Socket使用简明教程－ AsyncSocket">
<meta property="og:url" content="http://lp380490944.github.io/2015/12/29/2015/2015-11-2-iOS学习之Socket使用简明教程－ AsyncSocket/index.html">
<meta property="og:site_name" content="钟灵毓秀">
<meta property="og:description" content="iOS学习之Socket使用简明教程－ AsyncSocket">
<meta property="og:updated_time" content="2016-05-25T02:21:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS学习之Socket使用简明教程－ AsyncSocket">
<meta name="twitter:description" content="iOS学习之Socket使用简明教程－ AsyncSocket">
  
    <link rel="alternate" href="/atom.xml" title="钟灵毓秀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">钟灵毓秀</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">刘攀的博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lp380490944.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2015/2015-11-2-iOS学习之Socket使用简明教程－ AsyncSocket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/29/2015/2015-11-2-iOS学习之Socket使用简明教程－ AsyncSocket/" class="article-date">
  <time datetime="2015-12-29T08:27:58.000Z" itemprop="datePublished">2015-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/lessons/">lessons</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS学习之Socket使用简明教程－ AsyncSocket
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#iOS学习之Socket使用简明教程－ AsyncSocket</p>
<p>如果需要在项目中像QQ微信一样做到即时通讯，必须使用socket通讯，本人也是刚学习，分享一下，有什么不对的地方希望大家指正</p>
<p>ios原生的socket用起来不是很直观，所以我用的是AsyncSocket这个第三方库，对socket的封装比较好，只是好像没有带外传输（out—of-band） 如果你的服务器需要发送带外数据，可能得想下别的办法</p>
<p>环境</p>
<p>下载AsyncSocket<a href="https://github.com/robbiehanson/CocoaAsyncSocket类库，将RunLoop文件夹下的AsyncSocket.h" target="_blank" rel="external">https://github.com/robbiehanson/CocoaAsyncSocket类库，将RunLoop文件夹下的AsyncSocket.h</a>, AsyncSocket.m, AsyncUdpSocket.h, AsyncUdpSocket.m 文件拷贝到自己的project中</p>
<p>添加CFNetwork.framework, 在使用socket的文件头</p>
<pre><code>#import &lt;sys/socket.h&gt;
#import &lt;netinet/in.h&gt;
#import &lt;arpa/inet.h&gt;
#import &lt;unistd.h&gt;
</code></pre><p>使用</p>
<ol>
<li>socket 连接</li>
</ol>
<p>即时通讯最大的特点就是实时性，基本感觉不到延时或是掉线，所以必须对socket的连接进行监视与检测，在断线时进行重新连接，如果用户退出登录，要将socket手动关闭，否则对服务器会造成一定的负荷。</p>
<p>一般来说，一个用户（对于ios来说也就是我们的项目中）只能有一个正在连接的socket，所以这个socket变量必须是全局的，这里可以考虑使用单例或是AppDelegate进行数据共享，本文使用单例。如果对一个已经连接的socket对象再次进行连接操作，会抛出异常（不可对已经连接的socket进行连接）程序崩溃，所以在连接socket之前要对socket对象的连接状态进行判断</p>
<p>使用socket进行即时通讯还有一个必须的操作，即对服务器发送心跳包，每隔一段时间对服务器发送长连接指令（指令不唯一，由服务器端指定，包括使用socket发送消息，发送的数据和格式都是由服务器指定），如果没有收到服务器的返回消息，AsyncSocket会得到失去连接的消息，我们可以在失去连接的回调方法里进行重新连接。</p>
<p>先创建一个单例，命名为Singleton</p>
<pre><code>  Singleton.h

// Singleton.h
 #import &quot;AsyncSocket.h&quot;

 #define DEFINE_SHARED_INSTANCE_USING_BLOCK(block) \
static dispatch_once_t onceToken = 0; \
__strong static id sharedInstance = nil; \
dispatch_once(&amp;onceToken, ^{ \
sharedInstance = block(); \
}); \
return sharedInstance; \

@interface Singleton : NSObject

+ (Singleton *)sharedInstance;

@end
Singleton.m

+(Singleton *) sharedInstance
{

static Singleton *sharedInstace = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{

    sharedInstace = [[self alloc] init];
});

return sharedInstace;
}
</code></pre><p>这样一个单例就创建好了</p>
<p>在.h文件中生命socket变量</p>
<pre><code>@property (nonatomic, strong) AsyncSocket    *socket;       // socket
@property (nonatomic, copy  ) NSString       *socketHost;   // socket的Host
@property (nonatomic, assign) UInt16         socketPort;    // socket的prot
</code></pre><p>下面是连接，心跳，失去连接后重连</p>
<p>连接(长连接)</p>
<pre><code>在.h文件中声明方法，并声明代理&lt;AsyncSocketDelegate&gt;

-(void)socketConnectHost;// socket连接
在.m中实现，连接时host与port都是由服务器指定，如果不是自己写的服务器，请与服务器端开发人员交流

// socket连接
-(void)socketConnectHost{

    self.socket    = [[AsyncSocket alloc] initWithDelegate:self];

    NSError *error = nil;

    [self.socket connectToHost:self.socketHost onPort:self.socketPort withTimeout:3 error:&amp;error];

}
</code></pre><p>心跳</p>
<p>心跳通过计时器来实现<br>在singleton.h中声明一个定时器</p>
<pre><code>@property (nonatomic, retain) NSTimer        *connectTimer; // 计时器
</code></pre><p>在.m中实现连接成功回调方法，并在此方法中初始化定时器，发送心跳在后文向服务器发送数据时说明</p>
<pre><code>#pragma mark  - 连接成功回调
-(void)onSocket:(AsyncSocket *)sock didConnectToHost:(NSString  *)host port:(UInt16)port
</code></pre><p>{<br>    NSLog(@”socket连接成功”);</p>
<pre><code>// 每隔30s像服务器发送心跳包
self.connectTimer = [NSTimer scheduledTimerWithTimeInterval:30 target:self selector:@selector(longConnectToSocket) userInfo:nil repeats:YES];// 在longConnectToSocket方法中进行长连接需要向服务器发送的讯息

[self.connectTimer fire];
</code></pre><p>}</p>
<ol>
<li>socket 断开连接与重连</li>
</ol>
<p>断开连接</p>
<p>失去连接有几种情况，服务器断开，用户主动cut，还可能有如QQ其他设备登录被掉线的情况，不管那种情况，我们都能收到socket回调方法返回给我们的讯息，如果是用户退出登录或是程序退出而需要手动cut，我们在cut前对socket的userData赋予一个值来标记为用户退出，这样我们可以在收到断开信息时判断究竟是什么原因导致的掉线</p>
<p>在.h文件中声明一个枚举类型</p>
<pre><code> enum{
SocketOfflineByServer,// 服务器掉线，默认为0
SocketOfflineByUser,  // 用户主动cut
};
</code></pre><p>声明断开连接方法</p>
<pre><code>-(void)cutOffSocket; // 断开socket连接
</code></pre><p>.m</p>
<pre><code>// 切断socket
-(void)cutOffSocket{

self.socket.userData = SocketOfflineByUser;// 声明是由用户主动切断

[self.connectTimer invalidate];

[self.socket disconnect];
}
</code></pre><p>重连</p>
<p>实现代理方法</p>
<pre><code>-(void)onSocketDidDisconnect:(AsyncSocket *)sock
{
    NSLog(@&quot;sorry the connect is failure %ld&quot;,sock.userData);
    if (sock.userData == SocketOfflineByServer) {
        // 服务器掉线，重连
        [self socketConnectHost];
    }
    else if (sock.userData == SocketOfflineByUser) {
        // 如果由用户断开，不进行重连
        return;
    }

}
</code></pre><ol>
<li>socket 发送与接收数据</li>
</ol>
<p>发送数据<br>我们补充上文心跳连接未完成的方法</p>
<pre><code>// 心跳连接
-(void)longConnectToSocket{

// 根据服务器要求发送固定格式的数据，假设为指令@&quot;longConnect&quot;，但是一般不会是这么简单的指令

NSString *longConnect = @&quot;longConnect&quot;;

NSData   *dataStream  = [longConnect dataUsingEncoding:NSUTF8StringEncoding];

[self.socket writeData:dataStream withTimeout:1 tag:1];
</code></pre><p>}<br>socket发送数据是以栈的形式存放，所有数据放在一个栈中，存取时会出现粘包的现象，所以很多时候服务器在收发数据时是以先发送内容字节长度，再发送内容的形式，得到数据时也是先得到一个长度，再根据这个长度在栈中读取这个长度的字节流，如果是这种情况，发送数据时只需在发送内容前发送一个长度，发送方法与发送内容一样，假设长度为8</p>
<pre><code>NSData   *dataStream  = [@8 dataUsingEncoding:NSUTF8StringEncoding];

[self.socket writeData:dataStream withTimeout:1 tag:1];
接收数据 
为了能时刻接收到socket的消息，我们在长连接方法中进行读取数据

 [self.socket readDataWithTimeout:30 tag:0];
如果得到数据，会调用回调方法

-(void)onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
{
// 对得到的data值进行解析与转换即可

[self.socket readDataWithTimeout:30 tag:0];

}
</code></pre><ol>
<li>简单使用说明</li>
</ol>
<p>我们在用户登录后的第一个界面进行socket的初始化连接操作，在得到数据后，将所需要显示的数据放在singleton中，对变量进行监听后做出相应的操作即可，延伸起来比较复杂，没有真实数据也不太方便说明，大家自己进行探索吧，有问题请在下方留言</p>
<pre><code>[Singleton sharedInstance].socketHost = @&quot;192.186.100.21&quot;;// host设定
[Singleton sharedInstance].socketPort = 10045;// port设定

// 在连接前先进行手动断开
[Singleton sharedInstance].socket.userData = SocketOfflineByUser;
[[Singleton sharedInstance] cutOffSocket];

// 确保断开后再连，如果对一个正处于连接状态的socket进行连接，会出现崩溃
[Singleton sharedInstance].socket.userData = SocketOfflineByServer;
[[Singleton sharedInstance] socketConnectHost];
</code></pre><p> 本文转自<a href="http://my.oschina.net/joanfen/blog/287238" target="_blank" rel="external">这里</a>本文涉及到的代码在<a href="http://www.oschina.net/code/snippet_735123_36974" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lp380490944.github.io/2015/12/29/2015/2015-11-2-iOS学习之Socket使用简明教程－ AsyncSocket/" data-id="cj516xc34000f1huieln0mn2v" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/30/2016/2016-03-30mac技巧/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nieuwer</strong>
      <div class="article-nav-title">
        
          分享一个Mac的小技巧
        
      </div>
    </a>
  
  
    <a href="/2015/12/29/2015/2015-11-17-Block详解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Blocks 详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lessons/">lessons</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitlab/">gitlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lessons/">lessons</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tableview/">tableview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源、第三方/">开源、第三方</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/gitlab/" style="font-size: 10px;">gitlab</a> <a href="/tags/lessons/" style="font-size: 10px;">lessons</a> <a href="/tags/tableview/" style="font-size: 10px;">tableview</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/开源、第三方/" style="font-size: 10px;">开源、第三方</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/10/2017/1月/IOS中的-block关键字简单使用/"> IOS中的__block关键字简单使用</a>
          </li>
        
          <li>
            <a href="/2016/12/25/2016/12月/Gitlab的安装升级以及汉化操作说明/">Gitlab的安装，升级，以及汉化操作说明</a>
          </li>
        
          <li>
            <a href="/2016/07/29/2016/7月/iOS-UITableView-的beginUpdates和endUpdates/">iOS UITableView 的beginUpdates和endUpdates</a>
          </li>
        
          <li>
            <a href="/2016/07/25/2016/7月/使用jsonModel需要注意的/">使用jsonModel需要注意的</a>
          </li>
        
          <li>
            <a href="/2016/07/21/2016/7月/别人总结的开源项目和库/">别人总结的开源项目和库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Bluce Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>